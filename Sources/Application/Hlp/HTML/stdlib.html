<HTML>
<HEAD>
<TITLE>Standard Library Functions</TITLE>
</HEAD>
<BODY>

<P>
<TABLE style="WIDTH: 722px; HEIGHT: 20px" cellSpacing=2 cellPadding=5 width=722 
bgColor=#ffffff border=0>  
  <TR>
    <TD align=left bgColor=#ccccff>
      <P align=center><FONT face=Arial color=red size=5 
      ><STRONG>Standard Library 
      Functions</STRONG></FONT></P></TD></TR>
  <TR>
    <TD align=left bgColor=#eeeeff>
      <P>
      <FONT face=Arial size=2>
      This chapter groups utility functions useful in a variety of 
      programs. The corresponding declarations are in the header file
      <TT>`stdlib.h'</TT>.
      </FONT></P>
      <H2>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        ></FONT></P></BLOCKQUOTE><A name=abs ><FONT face=Arial size=3 
      color=blue><U>abs : integer absolute value 
      (magnitude)</U>  
         </FONT></A></H2>
      <P><A name=IDX2></A><FONT 
      face=Arial><FONT size=2><STRONG 
      >Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px"><FONT 
        face=Arial size=2>#include &lt;stdlib.h&gt; int 
        abs(int <VAR>i</VAR>);</FONT></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>abs 
        returns the absolute value of <VAR>i</VAR> (also 
        called the magnitude of <VAR>i</VAR>). That is, if 
        <VAR>i</VAR> is negative, the result is the 
        opposite of <VAR>i</VAR>, but if <VAR 
        >i</VAR> is nonnegative the result is <VAR 
        >i</VAR>. </FONT></P>
        <P><FONT face=Arial size=2>The 
        similar function labs uses and returns long rather than int 
        values.</FONT></P></BLOCKQUOTE>
      <P dir=ltr><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>The 
        result is a nonnegative integer. </FONT><FONT face=Arial 
        ><BR></FONT></P></BLOCKQUOTE>
      <H2>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        ></FONT></P></BLOCKQUOTE><A name=atexit ><FONT 
      face=Arial><FONT size=3 color=blue 
     ><U>atexit : request execution of functions at 
      program exit</U>  
            </FONT></FONT></A></H2>
      <P><A name=IDX4></A><FONT 
      face=Arial><FONT size=2><STRONG 
      >Synopsis</STRONG> </FONT></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        >#include &lt;stdlib.h&gt;<BR 
        >int atexit(void (*<VAR 
        >function</VAR>)(void); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>You 
        can use atexit to enroll functions in a list of functions that will be 
        called when your program terminates normally. The argument is a pointer 
        to a user-defined function (which must not require arguments and must 
        not return a result). The functions are kept in a LIFO stack; that is, 
        the last function enrolled by atexit will be the first to execute when 
        your program exits. There is no built-in limit to the number of 
        functions you can enroll in this list; however, after every group of 32 
        functions is enrolled, atexit will call malloc to get space for the next 
        part of the list. The initial list of 32 functions is statically 
        allocated, so you can always count on at least that many slots 
        available.</FONT></P></BLOCKQUOTE>
      <P dir=ltr><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P dir=ltr><FONT face=Arial 
        ><FONT size=2>atexit returns 0 if it succeeds in 
        enrolling your function, -1 if it fails (possible only if no space was 
        available for malloc to extend the list of 
      functions).</FONT></P></BLOCKQUOTE></FONT>
      <H2><ANAME=ATOF ><FONT face=Arial 
      size=3 color=blue><U>atof, atoff : string to double or 
      float</U>       
      </FONT></A></H2>
      <P><A name=IDX5></A><A name=IDX6 
      ></A><FONT face=Arial><FONT 
      size=2><STRONG>Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        >#include &lt;stdlib.h&gt;<BR 
        >double atof(const char *<VAR 
        >s</VAR>);<BR>float atoff(const 
        char *<VAR>s</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial><FONT 
      size=2><STRONG>Description</STRONG> 
</FONT></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT size=2><FONT face=Arial 
        >atof converts the initial portion of a string to a 
        double. atoff converts the initial portion of a string to a float. 
        </FONT><FONT face=Arial>The functions parse the 
        character string <VAR>s</VAR>, locating a substring 
        which can be converted to a floating point value. The substring must 
        match the format: </FONT><FONT face=Arial>[+|-]<VAR 
        >digits</VAR>[.][<VAR 
        >digits</VAR>][(e|E)[+|-]<VAR 
        >digits</VAR>] </FONT></FONT></P>
        <P><FONT face=Arial size=2>The 
        substring converted is the longest initial fragment of <VAR 
        >s</VAR> that has the expected format, beginning 
        with the first non-whitespace character. The substring is empty if str 
        is empty, consists entirely of whitespace, or if the first 
        non-whitespace character is something other than +, -, ., or a digit. 
        </FONT></P>
        <P><FONT face=Arial size=2 
        >atof(<VAR>s</VAR>) is 
        implemented as strtod(<VAR>s</VAR>, NULL). 
        atoff(<VAR>s</VAR>) is implemented as strtodf(<VAR 
        >s</VAR>, NULL). </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial><FONT 
      size=2><STRONG>Returns</STRONG> </FONT></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        >atof returns the converted substring value, if any, 
        as a double; or 0.0, if no conversion could be performed. If the correct 
        value is out of the range of representable values, plus or minus 
        HUGE_VAL is returned, and ERANGE is stored in errno. If the correct 
        value would cause underflow, 0.0 is returned and ERANGE is stored in 
        errno. </FONT></P>
        <P><FONT face=Arial size=2 
        >atoff obeys the same rules as atof, except that it 
        returns a float. </FONT></P></BLOCKQUOTE>
      <H2><A name=atoi ><FONT face=Arial 
      size=3 color=blue><U>atoi, atol : string to 
      integer</U>     </FONT></A></H2>
      <P><A name=IDX7></A><A name=IDX8 
      ></A><FONT face=Arial><FONT 
      size=2><STRONG>Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2 
        >#include &lt;stdlib.h&gt;<BR></FONT><FONT 
        face=Arial size=2>int atoi(const char *<VAR 
        >s</VAR>);<BR>long atol(const char *<VAR 
        >s</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>atoi converts the initial portion of a string 
        to an int. atol converts the initial portion of a string to a long. 
        </FONT><FONT face=Arial size=2>atoi(s) is 
        implemented as (int)strtol(s, NULL, 10). atol(s) is implemented as 
        strtol(s, NULL, 10).</FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>The functions return the converted value, if 
        any. If no conversion was made, 0 is returned. </FONT></P></BLOCKQUOTE>
      <H2><A name=bsearch ><FONT face=Arial 
      size=3 color=blue><U>bsearch : binary 
      search</U>   </FONT></A></H2>
      <P><A name=IDX9></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>#include 
        &lt;stdlib.h&gt;<BR>void *<BR>&nbsp;&nbsp;&nbsp; bsearch(const void 
        *<VAR>key</VAR>, const void *<VAR 
        >base</VAR>, size_t <VAR 
        >nmemb</VAR>, size_t <VAR 
        >size</VAR>, int (*<VAR 
        >compar</VAR>)(const void *, const void *)); 
        </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>bsearch searches an array beginning at <VAR 
        >base</VAR> for any element that matches <VAR 
        >key</VAR>, using binary search. <VAR 
        >nmemb</VAR> is the element count of the array; <VAR 
        >size</VAR> is the size of each element. </FONT></P>
        <P><FONT face=Arial size=2>The 
        array must be sorted in ascending order with respect to the comparison 
        function <VAR>compar</VAR> (which you supply as the 
        last argument of bsearch). </FONT></P>
        <P><FONT face=Arial size=2>You 
        must define the comparison function (*<VAR 
        >compar</VAR>) to have two arguments; its result 
        must be negative if the first argument is less than the second, zero if 
        the two arguments match, and positive if the first argument is greater 
        than the second (where "less than" and "greater than" refer to whatever 
        arbitrary ordering is appropriate). </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>Returns a pointer to an element of <VAR 
        >array</VAR> that matches <VAR 
        >key</VAR>. If more than one matching element is 
        available, the result may point to any of them. </FONT></P></BLOCKQUOTE>
      <H2><A name=calloc ><FONT face=Arial 
      size=3 color=blue><U>calloc : allocate 
      space for arrays</U>     
      </FONT></A></H2>
      <P><A name=IDX10></A><A 
      name=IDX11></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>#include 
        &lt;stdlib.h&gt; <BR>void *calloc(size_t <VAR 
        >n</VAR>, size_t <VAR>s</VAR>); 
        <BR>void *calloc_r(void *<VAR>reent</VAR>, size_t 
        &lt;n&gt;, &lt;size_t&gt; <VAR>s</VAR>); 
      </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>Use calloc to request a block of memory 
        sufficient to hold an array of <VAR>n</VAR> 
        elements, each of which has size <VAR>s</VAR>. 
        </FONT></P>
        <P><FONT face=Arial size=2>The 
        memory allocated by calloc comes out of the same memory pool used by 
        malloc, but the memory block is initialized to all zero bytes. (To avoid 
        the overhead of initializing the space, use malloc instead.) </FONT></P>
        <P><FONT face=Arial size=2>The 
        alternate functios _calloc_r is reentrant. The extra argument <VAR 
        >reent</VAR> is a pointer to a reentrancy structure. 
        </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>If successful, a pointer to the newly allocated 
      space. </FONT><FONT face=Arial size=2>If 
      unsuccessful, NULL. </FONT></P></BLOCKQUOTE>
      <H2><A name=div ><FONT face=Arial 
      size=3 color=blue><U>div : divide two 
      integers</U>    </FONT></A></H2>
      <P><A name=IDX12></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      div_t div(int <VAR>n</VAR>, int <VAR 
      >d</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>Divide returning quotient and remainder as two 
      integers in a structure div_t. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The result is represented with the structure 
      </FONT><FONT face=Arial size=2>typedef struct { int quot; 
      int rem; } div_t; </FONT></P>
      <P><FONT face=Arial size=2>where 
      the quot field represents the quotient, and rem the remainder. For nonzero 
      <VAR>d</VAR>, if `<VAR>r</VAR> = 
      div(<VAR>n</VAR>,<VAR>d</VAR>);' 
      then <VAR>n</VAR> equals `<VAR 
      >r</VAR>.rem + <VAR>d</VAR>*<VAR 
      >r</VAR>.quot'. </FONT></P>
      <P><FONT face=Arial size=2>To 
      divide long rather than int values, use the similar function 
      ldiv.</FONT></P></BLOCKQUOTE>
      <H2><A  name=ecvt ><FONT face=Arial 
      size=3 color=blue><U>ecvt,ecvtf,fcvt,fcvtf : double or 
      float to string</U>      
      </FONT></A></H2>
      <P><A name=IDX13></A><A 
      name=IDX14></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
        <P><FONT face=Arial size=2>#include 
        &lt;stdlib.h&gt;<BR>  
      char *ecvt(double <VAR>val</VAR>, int <VAR 
      >chars</VAR>, int *<VAR 
      >decpt</VAR>, int *<VAR 
        >sgn</VAR>);<BR> char *ecvtf(float <VAR 
        >val</VAR>, int <VAR>chars</VAR>, 
      int *<VAR>decpt</VAR>, int *<VAR 
        >sgn</VAR>);<BR> char *fcvt(double <VAR 
        >val</VAR>, int <VAR 
        >decimals</VAR>, int *<VAR 
        >decpt</VAR>, int *<VAR 
        >sgn</VAR>);<BR> </FONT><FONT face=Arial size=2> char *fcvtf(float <VAR 
        >val</VAR>, int <VAR 
        >decimals</VAR>, int *<VAR 
        >decpt</VAR>, int *<VAR 
        >sgn</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>ecvt and fcvt produce (null-terminated) strings 
      of digits representating the double number <VAR 
      >val</VAR>. ecvtf and fcvtf produce the corresponding 
      character representations of float numbers. </FONT><FONT face=Arial size=2>(The 
      stdlib functions ecvtbuf and fcvtbuf are reentrant versions of ecvt and 
      fcvt.) </FONT></P>
      <P><FONT face=Arial size=2>The 
      only difference between ecvt and fcvt is the interpretation of the second 
      argument (<VAR>chars</VAR> or <VAR 
        >decimals</VAR>). For ecvt, the second argument <VAR 
        >chars</VAR> specifies the total number of characters 
      to write (which is also the number of significant digits in the formatted 
      string, since these two functions write only digits). For fcvt, the second 
      argument <VAR>decimals</VAR> specifies the number of 
      characters to write after the decimal point; all digits for the integer 
      part of <VAR>val</VAR> are always included. 
      </FONT></P>
      <P><FONT face=Arial size=2>Since 
      ecvt and fcvt write only digits in the output string, they record the 
      location of the decimal point in *<VAR>decpt</VAR>, 
      and the sign of the number in *<VAR>sgn</VAR>. After 
      formatting a number, *<VAR>decpt</VAR> contains the 
      number of digits to the left of the decimal point. *<VAR 
        >sgn</VAR> contains 0 if the number is positive, and 1 
      if it is negative. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>All four functions return a pointer to the new 
      string containing a character representation of <VAR 
      >val</VAR>. </FONT></P></BLOCKQUOTE>
      <H2><A name=gvcvt ><FONT face=Arial 
      size=3 color=blue><U>gvcvt, gcvtf : format double or 
      float as string</U>        
      </FONT></A></H2>
      <P><A name=IDX15></A><A 
      name=IDX16></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      char *gcvt(double <VAR>val</VAR>, int <VAR 
        >precision</VAR>, char *<VAR 
        >buf</VAR>);<BR> char *gcvtf(float <VAR 
        >val</VAR>, int <VAR 
        >precision</VAR>, char *<VAR 
        >buf</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>gcvt writes a fully formatted number as a 
      null-terminated string in the buffer *<VAR>buf</VAR>. 
      gdvtf produces corresponding character representations of float numbers. 
      </FONT></P>
      <P><FONT face=Arial size=2>gcvt 
      uses the same rules as the printf format `%.<VAR 
        >precision</VAR>g' : only negative values are signed 
      (with `-'), and either exponential or ordinary decimal-fraction format is 
      chosen depending on the number of significant digits (specified by <VAR 
      >precision</VAR>). </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The result is a pointer to the formatted 
      representation of <VAR>val</VAR> (the same as the 
      argument <VAR>buf</VAR>). </FONT></P></BLOCKQUOTE>
      <H2><A name=ecvtbuf ><FONT face=Arial 
      size=3 color=blue><U>ecvtbuf, fcvtbuf : 
      double or float to string</U>       
      </FONT></A></H2>
      <P><A name=IDX17></A><A 
      name=IDX18></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdio.h&gt;<BR>  
      char *ecvtbuf(double <VAR>val</VAR>, int <VAR 
        >chars</VAR>, int *<VAR 
        >decpt</VAR>, int *<VAR 
        >sgn</VAR>, char *<VAR 
        >buf</VAR>);<BR> char *fcvtbuf(double <VAR 
        >val</VAR>, int <VAR 
        >decimals</VAR>, int *<VAR 
        >decpt</VAR>, int *<VAR 
        >sgn</VAR>, char *<VAR 
        >buf</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>ecvtbuf and fcvtbuf produce (null-terminated) 
      strings of digits representating the double number <VAR 
        >val</VAR>. </FONT></P>
      <P><FONT face=Arial size=2>The 
      only difference between ecvtbuf and fcvtbuf is the interpretation of the 
      second argument (<VAR>chars</VAR> or <VAR 
        >decimals</VAR>). For ecvtbuf, the second argument 
      <VAR>chars</VAR> specifies the total number of 
      characters to write (which is also the number of significant digits in the 
      formatted string, since these two functions write only digits). For 
      fcvtbuf, the second argument <VAR>decimals</VAR> 
      specifies the number of characters to write after the decimal point; all 
      digits for the integer part of <VAR>val</VAR> are 
      always included. </FONT></P>
      <P><FONT face=Arial size=2>Since 
      ecvtbuf and fcvtbuf write only digits in the output string, they record 
      the location of the decimal point in *<VAR 
        >decpt</VAR>, and the sign of the number in *<VAR 
        >sgn</VAR>. After formatting a number, *<VAR 
        >decpt</VAR> contains the number of digits to the left 
      of the decimal point. *<VAR>sgn</VAR> contains 0 if 
      the number is positive, and 1 if it is negative. For both functions, you 
      supply a pointer <VAR>buf</VAR> to an area of memory 
      to hold the converted string. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>Both functions return a pointer to <VAR 
      >buf</VAR>, the string containing a character 
      representation of <VAR>val</VAR>. </FONT></P></BLOCKQUOTE>
      <H2><A name=exit ><FONT face=Arial 
      size=3 color=blue><U>exit : end program 
      execution</U>    </FONT></A></H2>
      <P><A name=IDX19></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt; 
      void exit(int <VAR>code</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>Use exit to return control from a program to 
      the host operating environment. Use the argument <VAR 
      >code</VAR> to pass an exit status to the operating 
      environment: two particular values, EXIT_SUCCESS and EXIT_FAILURE, are 
      defined in `stdlib.h' to indicate success or failure in a portable 
      fashion. </FONT></P>
      <P><FONT face=Arial size=2>exit 
      does two kinds of cleanup before ending execution of your program. First, 
      it calls all application-defined cleanup functions you have enrolled with 
      atexit. Second, files and streams are cleaned up: any pending output is 
      delivered to the host system, each open file or stream is closed, and 
      files created by tmpfile are deleted. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>exit does not return to its caller. </FONT></P></BLOCKQUOTE>
      <H2><A name=getenv ><FONT face=Arial 
      size=3 color=blue><U>getenv : look up 
      environment variable</U>     
      </FONT></A></H2>
      <P><A name=IDX20></A><A 
      name=IDX21></A><FONT face=Arial 
      ><FONT size=2><STRONG 
      >Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      char *getenv(const char *<VAR>name</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>getenv searches the list of environment 
      variable names and values (using the global pointer `char **environ') for 
      a variable whose name matches the string at <VAR 
        >name</VAR>. If a variable name matches, getenv 
      returns a pointer to the associated value. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>A pointer to the (string) value of the 
      environment variable, or NULL if there is no such environment variable. 
      </FONT></P></BLOCKQUOTE>
      <H2><A name=labs ><FONT face=Arial 
      size=3 color=blue><U>labs : long integer absolute 
      value</U>     
      </FONT></A></H2>
      <P><A name=IDX22></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      long labs(long <VAR>i</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>labs returns the absolute value of <VAR 
      >i</VAR> (also called the magnitude of <VAR 
      >i</VAR>). That is, if <VAR 
      >i</VAR> is negative, the result is the opposite of 
      <VAR>i</VAR>, but if <VAR 
        >i</VAR> is nonnegative the result is <VAR 
        >i</VAR>. </FONT></P>
      <P><FONT face=Arial size=2>The 
      similar function abs uses and returns int rather than long values. 
      </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The result is a nonnegative long integer. 
      </FONT></P></BLOCKQUOTE>
      <H2><A name=ldiv ><FONT face=Arial 
      size=3 color=blue><U>ldiv : divide two long 
      integers</U>     
</FONT></A></H2>
      <P><A name=IDX23></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      ldiv_t ldiv(long <VAR>n</VAR>, long <VAR 
      >d</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>Divide returning quotient and remainder as two 
      long integers in a structure ldiv_t. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The result is represented with the structure 
      </FONT></P>
      <P><FONT face=Arial size=2>typedef struct { long 
      quot; long rem; } ldiv_t; </FONT></P>
      <P><FONT face=Arial size=2>where 
      the quot field represents the quotient, and rem the remainder. For nonzero 
      <VAR>d</VAR>, if `<VAR>r</VAR> = 
      ldiv(<VAR>n</VAR>,<VAR 
        >d</VAR>);' then <VAR>n</VAR> 
      equals `<VAR>r</VAR>.rem + <VAR 
        >d</VAR>*<VAR>r</VAR>.quot'. 
      </FONT></P>
      <P><FONT face=Arial size=2>To 
      divide int rather than long values, use the similar function div. 
      </FONT></P></BLOCKQUOTE>
      <H2><A name=malloc ><FONT face=Arial 
      size=3 color=blue><U>malloc, realloc, free 
      : manage memory</U>     
      </FONT></A></H2>
      <P><A name=IDX24></A><A 
      name=IDX25></A><A name=IDX26 
      ></A><A name=IDX27></A><A 
      name=IDX28></A><A name=IDX29 
      ></A><FONT face=Arial><FONT 
      size=2><STRONG>Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      void *malloc(size_t <VAR>nbytes</VAR>);<BR> void 
      *realloc(void *<VAR>aptr</VAR>, size_t <VAR 
        >nbytes</VAR>);<BR> void free(void *<VAR 
        >aptr</VAR>);<BR> void *_malloc_r(void *<VAR 
        >reent</VAR>, size_t <VAR 
        >nbytes</VAR>);<BR> void *_realloc_r(void *<VAR 
        >reent</VAR>, void *<VAR 
        >aptr</VAR>, size_t <VAR 
        >nbytes</VAR>);<BR> void _free_r(void *<VAR 
        >reent</VAR>, void *<VAR 
        >aptr</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>These functions manage a pool of system memory. 
      </FONT></P>
      <P><FONT face=Arial size=2>Use 
      malloc to request allocation of an object with at least <VAR 
        >nbytes</VAR> bytes of storage available. If the space 
      is available, malloc returns a pointer to a newly allocated block as its 
      result. </FONT></P>
      <P><FONT face=Arial size=2>If 
      you already have a block of storage allocated by malloc, but you no longer 
      need all the space allocated to it, you can make it smaller by calling 
      realloc with both the object pointer and the new desired size as 
      arguments. realloc guarantees that the contents of the smaller object 
      match the beginning of the original object. </FONT></P>
      <P><FONT face=Arial size=2 
       >Similarly, if you need more space for an object, use 
      realloc to request the larger size; again, realloc guarantees that the 
      beginning of the new, larger object matches the contents of the original 
      object. </FONT></P>
      <P><FONT face=Arial size=2>When 
      you no longer need an object originally allocated by malloc or realloc (or 
      the related function calloc), return it to the memory storage pool by 
      calling free with the address of the object as the argument. You can also 
      use realloc for this purpose by calling it with 0 as the <VAR 
        >nbytes</VAR> argument. </FONT></P>
      <P><FONT face=Arial size=2>The 
      alternate functions _malloc_r, _realloc_r, and _free_r are reentrant 
      versions. The extra argument <VAR>reent</VAR> is a 
      pointer to a reentrancy structure. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>malloc returns a pointer to the newly allocated 
      space, if successful; otherwise it returns NULL. If your application needs 
      to generate empty objects, you may use malloc(0) for this purpose. 
      </FONT></P>
      <P><FONT face=Arial size=2 
       >realloc returns a pointer to the new block of memory, 
      or NULL if a new block could not be allocated. NULL is also the result 
      when you use `realloc(<VAR>aptr</VAR>,0)' (which has 
      the same effect as `free(<VAR>aptr</VAR>)'). You 
      should always check the result of realloc; successful reallocation is not 
      guaranteed even when you request a smaller object. </FONT></P>
      <P><FONT face=Arial size=2>free 
      does not return a result. </FONT></P></BLOCKQUOTE>
      <H2><A name=mbtowc ><FONT face=Arial 
      size=3 color=blue><U>mbtowc : minimal 
      multibyte to wide char converter</U>       
      </FONT></A></H2>
      <P><A name=IDX30></A><FONT 
      face=Arial><FONT size=2><STRONG 
      >Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      int mbtowc(wchar_t *<VAR>pwc</VAR>, const char *<VAR 
        >s</VAR>, size_t <VAR>n</VAR>); 
      </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>This is a minimal ANSI-conforming 
      implementation of mbtowc. The only "multi-byte character sequences" 
      recognized are single bytes, and they are "converted" to themselves. 
      </FONT></P>
      <P><FONT face=Arial size=2>Each 
      call to mbtowc copies one character from *<VAR 
        >s</VAR> to *<VAR>pwc</VAR>, 
      unless <VAR>s</VAR> is a null pointer. </FONT></P>
      <P><FONT face=Arial size=2>In 
      this implementation, the argument <VAR>n</VAR> is 
      ignored. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>This implementation of mbtowc returns 0 if <VAR 
      >s</VAR> is NULL; it returns 1 otherwise (reporting 
      the length of the character "sequence" used). </FONT></P></BLOCKQUOTE>
      <H2><A name=qsort ><FONT face=Arial 
      size=3 color=blue><U>qsort : sort an 
      array</U>    </FONT></A></H2>
      <P><A name=IDX31></A><FONT 
      face=Arial><FONT size=2><STRONG 
      >Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      void qsort(void *<VAR>base</VAR>, size_t <VAR 
        >nmemb</VAR>, size_t <VAR 
        >size</VAR>, int (*<VAR 
        >compar</VAR>)(const void *, const void *) ); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>qsort sorts an array (beginning at <VAR 
      >base</VAR>) of <VAR>nmemb</VAR> 
      objects. <VAR>size</VAR> describes the size of each 
      element of the array. </FONT></P>
      <P><FONT face=Arial size=2>You 
      must supply a pointer to a comparison function, using the argument shown 
      as <VAR>compar</VAR>. (This permits sorting objects 
      of unknown properties.) Define the comparison function to accept two 
      arguments, each a pointer to an element of the array starting at <VAR 
        >base</VAR>. The result of (*<VAR 
        >compar</VAR>) must be negative if the first argument 
      is less than the second, zero if the two arguments match, and positive if 
      the first argument is greater than the second (where "less than" and 
      "greater than" refer to whatever arbitrary ordering is appropriate). 
      </FONT></P>
      <P><FONT face=Arial size=2>The 
      array is sorted in place; that is, when qsort returns, the array elements 
      beginning at <VAR>base</VAR> have been reordered. 
      </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>qsort does not return a result. </FONT></P></BLOCKQUOTE>
      <H2><A name=rand ><FONT face=Arial 
      size=3 color=blue><U>rand, srand : pseudo-random 
      numbers</U>    
      </FONT></A></H2>
      <P><A name=IDX32></A><A 
      name=IDX33></A><A name=IDX34 
      ></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>int rand(void);<BR>  
        void srand(unsigned int <VAR 
        >seed</VAR>);<BR> int rand_r(unsigned int *<VAR 
      >seed</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>rand returns a different integer each time it 
      is called; each integer is chosen by an algorithm designed to be 
      unpredictable, so that you can use rand when you require a random number. 
      The algorithm depends on a static variable called the "random seed"; 
      starting with a given value of the random seed always produces the same 
      sequence of numbers in successive calls to rand. </FONT></P>
      <P><FONT face=Arial size=2>You 
      can set the random seed using srand; it does nothing beyond storing its 
      argument in the static variable used by rand. You can exploit this to make 
      the pseudo-random sequence less predictable, if you wish, by using some 
      other unpredictable value (often the least significant parts of a 
      time-varying value) as the random seed before beginning a sequence of 
      calls to rand; or, if you wish to ensure (for example, while debugging) 
      that successive runs of your program use the same "random" numbers, you 
      can use srand to set the same random seed at the outset. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>rand returns the next pseudo-random integer in 
      sequence; it is a number between 0 and RAND_MAX (inclusive). </FONT></P>
      <P><FONT face=Arial size=2>srand 
      does not return a result. </FONT></P></BLOCKQUOTE>
      <H2><A name=strtod ><FONT face=Arial 
      size=3 color=blue><U>strtod, strtodf : 
      string to double or float</U>       
      </FONT></A></H2>
      <P><A name=IDX35></A><A 
      name=IDX36></A><A name=IDX37 
      ></A><FONT face=Arial><FONT 
      size=2><STRONG>Synopsis</STRONG> </FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      double strtod(const char *<VAR>str</VAR>, char **<VAR 
        >tail</VAR>);<BR> float strtodf(const char *<VAR 
        >str</VAR>, char **<VAR 
        >tail</VAR>);<BR> double _strtod_r(void *<VAR 
        >reent</VAR>, const char *<VAR 
        >str</VAR>, char **<VAR 
        >tail</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT size=2><FONT face=Arial>The function strtod parses the character 
      string <VAR>str</VAR>, producing a substring which 
      can be converted to a double value. The substring converted is the longest 
      initial subsequence of <VAR>str</VAR>, beginning with 
      the first non-whitespace character, that has the format: </FONT><FONT 
      face=Arial>[+|-]<VAR 
        >digits</VAR>[.][<VAR 
        >digits</VAR>][(e|E)[+|-]<VAR 
        >digits</VAR>] </FONT></FONT></P>
      <P><FONT face=Arial size=2>The 
      substring contains no characters if <VAR>str</VAR> is 
      empty, consists entirely of whitespace, or if the first non-whitespace 
      character is something other than +, -, ., or a digit. If the substring is 
      empty, no conversion is done, and the value of <VAR 
        >str</VAR> is stored in *<VAR 
        >tail</VAR>. Otherwise, the substring is converted, 
      and a pointer to the final string (which will contain at least the 
      terminating null character of <VAR>str</VAR>) is 
      stored in *<VAR>tail</VAR>. If you want no assignment 
      to *<VAR>tail</VAR>, pass a null pointer as <VAR 
      >tail</VAR>. strtodf is identical to strtod except for 
      its return type. </FONT></P>
      <P><FONT face=Arial size=2>This 
      implementation returns the nearest machine number to the input decimal 
      string. Ties are broken by using the IEEE round-even rule. </FONT></P>
      <P><FONT face=Arial size=2>The 
      alternate function _strtod_r is a reentrant version. The extra argument 
      <VAR>reent</VAR> is a pointer to a reentrancy 
      structure. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>strtod returns the converted substring value, 
      if any. If no conversion could be performed, 0 is returned. If the correct 
      value is out of the range of representable values, plus or minus HUGE_VAL 
      is returned, and ERANGE is stored in errno. If the correct value would 
      cause underflow, 0 is returned and ERANGE is stored in errno. </FONT></P></BLOCKQUOTE>
      <H2><A name=strtol ><FONT face=Arial 
      size=3 color=blue><U>strtol : string to 
      long</U>    </FONT></A></H2>
      <P><A name=IDX38></A><A 
      name=IDX39></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt; 
      long strtol(const char *<VAR>s</VAR>, char **<VAR 
        >ptr</VAR>,int <VAR>base</VAR>); 
      long _strtol_r(void *<VAR>reent</VAR>, const char 
      *<VAR>s</VAR>, char **<VAR 
        >ptr</VAR>,int <VAR>base</VAR>); 
      </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The function strtol converts the string *<VAR 
      >s</VAR> to a long. First, it breaks down the string 
      into three parts: leading whitespace, which is ignored; a subject string 
      consisting of characters resembling an integer in the radix specified by 
      <VAR>base</VAR>; and a trailing portion consisting of 
      zero or more unparseable characters, and always including the terminating 
      null character. Then, it attempts to convert the subject string into a 
      long and returns the result. </FONT></P>
      <P><FONT face=Arial size=2>If 
      the value of <VAR>base</VAR> is 0, the subject string 
      is expected to look like a normal C integer constant: an optional sign, a 
      possible `0x' indicating a hexadecimal base, and a number. If <VAR 
      >base</VAR> is between 2 and 36, the expected form of 
      the subject is a sequence of letters and digits representing an integer in 
      the radix specified by <VAR>base</VAR>, with an 
      optional plus or minus sign. The letters a--z (or, equivalently, A--Z) are 
      used to signify values from 10 to 35; only letters whose ascribed values 
      are less than <VAR>base</VAR> are permitted. If <VAR 
      >base</VAR> is 16, a leading 0x is permitted. 
      </FONT></P>
      <P><FONT face=Arial size=2>The 
      subject sequence is the longest initial sequence of the input string that 
      has the expected form, starting with the first non-whitespace character. 
      If the string is empty or consists entirely of whitespace, or if the first 
      non-whitespace character is not a permissible letter or digit, the subject 
      string is empty. </FONT></P>
      <P><FONT face=Arial size=2>If 
      the subject string is acceptable, and the value of <VAR 
        >base</VAR> is zero, strtol attempts to determine the 
      radix from the input string. A string with a leading 0x is treated as a 
      hexadecimal value; a string with a leading 0 and no x is treated as octal; 
      all other strings are treated as decimal. If <VAR 
        >base</VAR> is between 2 and 36, it is used as the 
      conversion radix, as described above. If the subject string begins with a 
      minus sign, the value is negated. Finally, a pointer to the first 
      character past the converted subject string is stored in <VAR 
        >ptr</VAR>, if <VAR>ptr</VAR> is 
      not NULL. </FONT></P>
      <P><FONT face=Arial size=2>If 
      the subject string is empty (or not in acceptable form), no conversion is 
      performed and the value of <VAR>s</VAR> is stored in 
      <VAR>ptr</VAR> (if <VAR 
        >ptr</VAR> is not NULL). </FONT></P>
      <P><FONT face=Arial size=2>The 
      alternate function _strtol_r is a reentrant version. The extra argument 
      <VAR>reent</VAR> is a pointer to a reentrancy 
      structure. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>strtol returns the converted value, if any. If 
      no conversion was made, 0 is returned. </FONT></P>
      <P><FONT face=Arial size=2 
       >strtol returns LONG_MAX or LONG_MIN if the magnitude 
      of the converted value is too large, and sets errno to ERANGE. </FONT></P></BLOCKQUOTE>
      <H2><A name=strtoul ><FONT face=Arial 
      size=3 color=blue><U>strtoul : string to 
      unsigned long</U>     
      </FONT></A></H2>
      <P><A name=IDX40></A><A 
      name=IDX41></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      unsigned long strtoul(const char *<VAR>s</VAR>, char 
      **<VAR>ptr</VAR>, int <VAR 
        >base</VAR>);<BR> unsigned long _strtoul_r(void *<VAR 
        >reent</VAR>, const char *<VAR 
        >s</VAR>, char **<VAR>ptr</VAR>, 
      int <VAR>base</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>The function strtoul converts the string *<VAR 
      >s</VAR> to an unsigned long. First, it breaks down 
      the string into three parts: leading whitespace, which is ignored; a 
      subject string consisting of the digits meaningful in the radix specified 
      by <VAR>base</VAR> (for example, 0 through 7 if the 
      value of <VAR>base</VAR> is 8); and a trailing 
      portion consisting of one or more unparseable characters, which always 
      includes the terminating null character. Then, it attempts to convert the 
      subject string into an unsigned long integer, and returns the result. 
      </FONT></P>
      <P><FONT face=Arial size=2>If 
      the value of <VAR>base</VAR> is zero, the subject 
      string is expected to look like a normal C integer constant (save that no 
      optional sign is permitted): a possible 0x indicating hexadecimal radix, 
      and a number. If <VAR>base</VAR> is between 2 and 36, 
      the expected form of the subject is a sequence of digits (which may 
      include letters, depending on the base) representing an integer in the 
      radix specified by <VAR>base</VAR>. The letters a--z 
      (or A--Z) are used as digits valued from 10 to 35. If <VAR 
        >base</VAR> is 16, a leading 0x is permitted. 
      </FONT></P>
      <P><FONT face=Arial size=2>The 
      subject sequence is the longest initial sequence of the input string that 
      has the expected form, starting with the first non-whitespace character. 
      If the string is empty or consists entirely of whitespace, or if the first 
      non-whitespace character is not a permissible digit, the subject string is 
      empty. </FONT></P>
      <P><FONT face=Arial size=2>If 
      the subject string is acceptable, and the value of <VAR 
        >base</VAR> is zero, strtoul attempts to determine the 
      radix from the input string. A string with a leading 0x is treated as a 
      hexadecimal value; a string with a leading 0 and no x is treated as octal; 
      all other strings are treated as decimal. If <VAR 
        >base</VAR> is between 2 and 36, it is used as the 
      conversion radix, as described above. Finally, a pointer to the first 
      character past the converted subject string is stored in <VAR 
        >ptr</VAR>, if <VAR>ptr</VAR> is 
      not NULL. </FONT></P>
      <P><FONT face=Arial size=2>If 
      the subject string is empty (that is, if *<VAR 
        >s</VAR> does not start with a substring in acceptable 
      form), no conversion is performed and the value of <VAR 
        >s</VAR> is stored in <VAR 
        >ptr</VAR> (if <VAR>ptr</VAR> is 
      not NULL). </FONT></P>
      <P><FONT face=Arial size=2>The 
      alternate function _strtoul_r is a reentrant version. The extra argument 
      <VAR>reent</VAR> is a pointer to a reentrancy 
      structure. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>strtoul returns the converted value, if any. If 
      no conversion was made, 0 is returned. </FONT></P>
      <P><FONT face=Arial size=2 
       >strtoul returns ULONG_MAX if the magnitude of the 
      converted value is too large, and sets errno to ERANGE. </FONT></P></BLOCKQUOTE>
      <H2><A name=system ><FONT face=Arial 
      size=3 color=blue><U>system : execute 
      command string</U>    
</FONT></A></H2>
      <P><A name=IDX42></A><A 
      name=IDX43></A><FONT size=2><FONT face=Arial 
      ><STRONG>Synopsis</STRONG></FONT> 
      </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt;<BR>  
      int system(char *<VAR>s</VAR>);<BR> int _system_r(void 
      *<VAR>reent</VAR>, char *<VAR 
        >s</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial><FONT 
      size=2><STRONG>Description</STRONG><BR 
      ></P></FONT></FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>Use 
      system to pass a command string *<VAR>s</VAR> to 
      /bin/sh on your system, and wait for it to finish executing. </FONT></P>
      <P><FONT face=Arial size=2>Use 
      `system(NULL)' to test whether your system has /bin/sh available. 
      </FONT></P>
      <P><FONT face=Arial size=2>The 
      alternate function _system_r is a reentrant version. The extra argument 
      <VAR>reent</VAR> is a pointer to a reentrancy 
      structure. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>system(NULL) returns a non-zero value if 
      /bin/sh is available, and 0 if it is not. </FONT></P>
      <P><FONT face=Arial size=2>With 
      a command argument, the result of system is the exit status returned by 
      /bin/sh. </FONT></P></BLOCKQUOTE>
      <H2><A name=wctomb ><FONT face=Arial 
      size=3 color=blue><U>wctomb : minimal wide 
      char to multibyte converter</U>       
      </FONT></A></H2>
      <P><A name=IDX44></A><FONT 
      size=2><FONT face=Arial><STRONG 
      >Synopsis</STRONG></FONT> </FONT>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>#include &lt;stdlib.h&gt; <BR>  
      int wctomb(char *<VAR>s</VAR>, wchar_t <VAR 
        >wchar</VAR>); </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Description</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>This is a minimal ANSI-conforming 
      implementation of wctomb. The only "wide characters" recognized are single 
      bytes, and they are "converted" to themselves. </FONT></P>
      <P><FONT face=Arial size=2>Each 
      call to wctomb copies the character <VAR>wchar</VAR> 
      to *<VAR>s</VAR>, unless <VAR 
        >s</VAR> is a null pointer. </FONT></P></BLOCKQUOTE>
      <P><FONT face=Arial size=2 
      ><STRONG 
      >Returns</STRONG></FONT></P>
      <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
      <P><FONT face=Arial size=2>This implementation of wctomb returns 0 if <VAR 
      >s</VAR> is NULL; it returns 1 otherwise (reporting 
      the length of the character "sequence" generated). 
  </FONT></P></BLOCKQUOTE></TD></TR></TABLE></P>
</BODY>
</HTML>
